name: ADF-CI-CD

# Manual trigger with parameters
on:
  workflow_dispatch:
    inputs:
      # Name of your Azure ADF
      ADF_NAME:
        description: 'ADF Name to Deploy'
        required: true
        default: 'ADF-MyADFProject-{REPLACE-ME e.g. Feature-A-QA}'

      # Name of the publish folder under adf_publish bnrach
      ADF_PUBLISH_FOLDER:
        description: 'ADF Publish Folder Name in Git (under adf_publish branch)'
        required: true
        default: 'ADF-MyADFProject-{REPLACE-ME e.g. Feature-A}'

      # This resource group for the ADF
      RESOURCE_GROUP:
        description: 'Resource Group Name'
        required: true
        default: 'ADF-Dev-Ops'

      # The Azure region to which to deploy your resources
      LOCATION:
        description: 'Azure Region'
        required: true
        default: 'EastUS2'

      # For running PowerShell and creating resources
      SUBSCRIPTION_ID:
        description: 'Azure Subscription Id'
        required: true
        default: '00000000-0000-0000-0000-000000000000'

jobs:
  #############################################################
  # This is packaging up the files from Git to the Artifacts files
  #############################################################
  Build:
    runs-on: ubuntu-latest

    # Checkout code
    steps:
    - name: Checkout repo
      uses: actions/checkout@v2

    # Show paths
    - name: Show paths
      run: ls -R

    # Show the environment variables for debugging
    - name: Display Environment Variable
      uses: azure/powershell@v1
      with:
        inlineScript: |
          dir env:
        azPSVersion: '3.1.0'

    # Publish Artifact: Publish: ARM-Templates
    - name: 'Publish Artifact: ARM-Templates' 
      uses: actions/upload-artifact@v2
      with:
        name: 'ARM-Templates'
        path: '${{ github.workspace }}/ARM-Templates'

    # Publish Artifact: Publish: PowerShell-Scripts
    - name: 'Publish Artifact: PowerShell-Scripts' 
      uses: actions/upload-artifact@v2
      with:
        name: 'PowerShell-Scripts'
        path: '${{ github.workspace }}/PowerShell-Scripts'

    - name: Checkout adf_publish branch
      uses: actions/checkout@v2
      with:
        ref: adf_publish

    # Show paths
    - name: Show paths
      run: ls -R

    # Publish Artifact: adf_publish files
    - name: 'Publish Artifact: adf_publish' 
      uses: actions/upload-artifact@v2
      with:
        name: 'Publish-Files'
        path: '${{ github.workspace }}/${{ github.event.inputs.ADF_PUBLISH_FOLDER }}'


        
#############################################################
# Deploy 
#############################################################
  Dev:
    needs: Build
    runs-on: ubuntu-latest

    steps:
    # Show the environment variables for debugging
    - name: Display Environment Variable
      uses: azure/powershell@v1
      with:
        inlineScript: |
          dir env:
        azPSVersion: '3.1.0'        

    # Download Artifact: ARM-Templates
    - name: 'Download Artifact: ARM-Templates' 
      uses: actions/download-artifact@v2
      with:
        name: 'ARM-Templates'
        path: ${{ github.workspace }}/ARM-Templates

    # Download Artifact:PowerShell-Scripts
    - name: 'Download Artifact: PowerShell-Scripts' 
      uses: actions/download-artifact@v2
      with:
        name: 'PowerShell-Scripts'
        path: ${{ github.workspace }}/PowerShell-Scripts

    # Download Artifact: Publish-Files
    - name: 'Download Artifact: Publish-Files' 
      uses: actions/download-artifact@v2
      with:
        name: 'Publish-Files'
        path: ${{ github.workspace }}/Publish-Files

    # Login to Azure
    - name: Login via Az module
      uses: azure/login@v1.1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        # set this if you will be using PowerShell
        enable-AzPSSession: true 

    # Deploy ADF Azure Resource
    - name: Deploy ARM Template (ADF)
      uses: azure/CLI@v1
      # if: ${{ github.event.inputs.MODE == 'SKIP FOR TESTING' }}
      with:
        inlineScript: |
          az group create --location "${{ github.event.inputs.LOCATION }}" --name "${{ github.event.inputs.RESOURCE_GROUP }}"
          az deployment group create --resource-group ${{ github.event.inputs.RESOURCE_GROUP }} --template-file $GITHUB_WORKSPACE/ARM-Templates/Create-ADF-Template.json --parameters @$GITHUB_WORKSPACE/ARM-Templates/Create-ADF-Parameters.json --parameters name="${{ github.event.inputs.ADF_NAME }}"

    # Currently there is not an Azure PowerShell Action for calling a PowerShell script file.  This is inline for now...
    # ADF Pre-Deployment - Stop ADF Triggers
    - name: ADF Pre-Deployment - Stop ADF Triggers
      uses: azure/powershell@v1
      with:
        inlineScript: |
          [String] $path= $env:GITHUB_WORKSPACE
          Write-Output $path
          [String] $templatePath = "/Publish-Files/ARMTemplateForFactory.json"
          [String] $armTemplate = $path + $templatePath
          Write-Output $armTemplate
          [String] $ResourceGroupName = "${{ github.event.inputs.RESOURCE_GROUP }}"
          [String] $DataFactoryName = "${{ github.event.inputs.ADF_NAME }}"
          [Bool] $predeployment = $true
          [Bool] $deleteDeployment = $false

          function getPipelineDependencies {
              param([System.Object] $activity)
              if ($activity.Pipeline) {
                  return @($activity.Pipeline.ReferenceName)
              } elseif ($activity.Activities) {
                  $result = @()
                  $activity.Activities | ForEach-Object{ $result += getPipelineDependencies -activity $_ }
                  return $result
              } elseif ($activity.ifFalseActivities -or $activity.ifTrueActivities) {
                  $result = @()
                  $activity.ifFalseActivities | Where-Object {$_ -ne $null} | ForEach-Object{ $result += getPipelineDependencies -activity $_ }
                  $activity.ifTrueActivities | Where-Object {$_ -ne $null} | ForEach-Object{ $result += getPipelineDependencies -activity $_ }
                  return $result
              } elseif ($activity.defaultActivities) {
                  $result = @()
                  $activity.defaultActivities | ForEach-Object{ $result += getPipelineDependencies -activity $_ }
                  if ($activity.cases) {
                      $activity.cases | ForEach-Object{ $_.activities } | ForEach-Object{$result += getPipelineDependencies -activity $_ }
                  }
                  return $result
              } else {
                  return @()
              }
          }

          function pipelineSortUtil {
              param([Microsoft.Azure.Commands.DataFactoryV2.Models.PSPipeline]$pipeline,
              [Hashtable] $pipelineNameResourceDict,
              [Hashtable] $visited,
              [System.Collections.Stack] $sortedList)
              if ($visited[$pipeline.Name] -eq $true) {
                  return;
              }
              $visited[$pipeline.Name] = $true;
              $pipeline.Activities | ForEach-Object{ getPipelineDependencies -activity $_ -pipelineNameResourceDict $pipelineNameResourceDict}  | ForEach-Object{
                  pipelineSortUtil -pipeline $pipelineNameResourceDict[$_] -pipelineNameResourceDict $pipelineNameResourceDict -visited $visited -sortedList $sortedList
              }
              $sortedList.Push($pipeline)

          }

          function Get-SortedPipelines {
              param(
                  [string] $DataFactoryName,
                  [string] $ResourceGroupName
              )
              $pipelines = Get-AzDataFactoryV2Pipeline -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $ppDict = @{}
              $visited = @{}
              $stack = new-object System.Collections.Stack
              $pipelines | ForEach-Object{ $ppDict[$_.Name] = $_ }
              $pipelines | ForEach-Object{ pipelineSortUtil -pipeline $_ -pipelineNameResourceDict $ppDict -visited $visited -sortedList $stack }
              $sortedList = new-object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSPipeline]
              
              while ($stack.Count -gt 0) {
                  $sortedList.Add($stack.Pop())
              }
              $sortedList
          }

          function triggerSortUtil {
              param([Microsoft.Azure.Commands.DataFactoryV2.Models.PSTrigger]$trigger,
              [Hashtable] $triggerNameResourceDict,
              [Hashtable] $visited,
              [System.Collections.Stack] $sortedList)
              if ($visited[$trigger.Name] -eq $true) {
                  return;
              }
              $visited[$trigger.Name] = $true;
              $trigger.Properties.DependsOn | Where-Object {$_ -and $_.ReferenceTrigger} | ForEach-Object{
                  triggerSortUtil -trigger $triggerNameResourceDict[$_.ReferenceTrigger.ReferenceName] -triggerNameResourceDict $triggerNameResourceDict -visited $visited -sortedList $sortedList
              }
              $sortedList.Push($trigger)
          }

          function Get-SortedTriggers {
              param(
                  [string] $DataFactoryName,
                  [string] $ResourceGroupName
              )
              $triggers = Get-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName
              $triggerDict = @{}
              $visited = @{}
              $stack = new-object System.Collections.Stack
              $triggers | ForEach-Object{ $triggerDict[$_.Name] = $_ }
              $triggers | ForEach-Object{ triggerSortUtil -trigger $_ -triggerNameResourceDict $triggerDict -visited $visited -sortedList $stack }
              $sortedList = new-object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSTrigger]
              
              while ($stack.Count -gt 0) {
                  $sortedList.Add($stack.Pop())
              }
              $sortedList
          }

          function Get-SortedLinkedServices {
              param(
                  [string] $DataFactoryName,
                  [string] $ResourceGroupName
              )
              $linkedServices = Get-AzDataFactoryV2LinkedService -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName
              $LinkedServiceHasDependencies = @('HDInsightLinkedService', 'HDInsightOnDemandLinkedService', 'AzureBatchLinkedService')
              $Akv = 'AzureKeyVaultLinkedService'
              $HighOrderList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]
              $RegularList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]
              $AkvList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]

              $linkedServices | ForEach-Object {
                  if ($_.Properties.GetType().Name -in $LinkedServiceHasDependencies) {
                      $HighOrderList.Add($_)
                  }
                  elseif ($_.Properties.GetType().Name -eq $Akv) {
                      $AkvList.Add($_)
                  }
                  else {
                      $RegularList.Add($_)
                  }
              }

              $SortedList = New-Object Collections.Generic.List[Microsoft.Azure.Commands.DataFactoryV2.Models.PSLinkedService]($HighOrderList.Count + $RegularList.Count + $AkvList.Count)
              $SortedList.AddRange($HighOrderList)
              $SortedList.AddRange($RegularList)
              $SortedList.AddRange($AkvList)
              $SortedList
          }

          $templateJson = Get-Content $armTemplate | ConvertFrom-Json
          $resources = $templateJson.resources

          #Triggers 
          Write-Host "Getting triggers"
          $triggersInTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/triggers" }
          $triggerNamesInTemplate = $triggersInTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40)}

          $triggersDeployed = Get-SortedTriggers -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName

          $triggersToStop = $triggersDeployed | Where-Object { $triggerNamesInTemplate -contains $_.Name } | ForEach-Object { 
              New-Object PSObject -Property @{
                  Name = $_.Name
                  TriggerType = $_.Properties.GetType().Name 
              }
          }
          $triggersToDelete = $triggersDeployed | Where-Object { $triggerNamesInTemplate -notcontains $_.Name } | ForEach-Object { 
              New-Object PSObject -Property @{
                  Name = $_.Name
                  TriggerType = $_.Properties.GetType().Name 
              }
          }
          $triggersToStart = $triggersInTemplate | Where-Object { $_.properties.runtimeState -eq "Started" -and ($_.properties.pipelines.Count -gt 0 -or $_.properties.pipeline.pipelineReference -ne $null)} | ForEach-Object { 
              New-Object PSObject -Property @{
                  Name = $_.name.Substring(37, $_.name.Length-40)
                  TriggerType = $_.Properties.type
              }
          }

          if ($predeployment -eq $true) {
              #Stop all triggers
              Write-Host "Stopping deployed triggers`n"
              $triggersToStop | ForEach-Object {
                  if ($_.TriggerType -eq "BlobEventsTrigger") {
                      Write-Host "Unsubscribing" $_.Name "from events"
                      $status = Remove-AzDataFactoryV2TriggerSubscription -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                      while ($status.Status -ne "Disabled"){
                          Start-Sleep -s 15
                          $status = Get-AzDataFactoryV2TriggerSubscriptionStatus -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                      }
                  }
                  Write-Host "Stopping trigger" $_.Name
                  Stop-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name -Force
              }
          }
          else {
              #Deleted resources
              #pipelines
              Write-Host "Getting pipelines"
              $pipelinesADF = Get-SortedPipelines -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $pipelinesTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/pipelines" }
              $pipelinesNames = $pipelinesTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40)}
              $deletedpipelines = $pipelinesADF | Where-Object { $pipelinesNames -notcontains $_.Name }
              #dataflows
              $dataflowsADF = Get-AzDataFactoryV2DataFlow -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $dataflowsTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/dataflows" }
              $dataflowsNames = $dataflowsTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40) }
              $deleteddataflow = $dataflowsADF | Where-Object { $dataflowsNames -notcontains $_.Name }
              #datasets
              Write-Host "Getting datasets"
              $datasetsADF = Get-AzDataFactoryV2Dataset -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $datasetsTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/datasets" }
              $datasetsNames = $datasetsTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40) }
              $deleteddataset = $datasetsADF | Where-Object { $datasetsNames -notcontains $_.Name }
              #linkedservices
              Write-Host "Getting linked services"
              $linkedservicesADF = Get-SortedLinkedServices -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $linkedservicesTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/linkedservices" }
              $linkedservicesNames = $linkedservicesTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40)}
              $deletedlinkedservices = $linkedservicesADF | Where-Object { $linkedservicesNames -notcontains $_.Name }
              #Integrationruntimes
              Write-Host "Getting integration runtimes"
              $integrationruntimesADF = Get-AzDataFactoryV2IntegrationRuntime -DataFactoryName $DataFactoryName -ResourceGroupName $ResourceGroupName
              $integrationruntimesTemplate = $resources | Where-Object { $_.type -eq "Microsoft.DataFactory/factories/integrationruntimes" }
              $integrationruntimesNames = $integrationruntimesTemplate | ForEach-Object {$_.name.Substring(37, $_.name.Length-40)}
              $deletedintegrationruntimes = $integrationruntimesADF | Where-Object { $integrationruntimesNames -notcontains $_.Name }

              #Delete resources
              Write-Host "Deleting triggers"
              $triggersToDelete | ForEach-Object { 
                  Write-Host "Deleting trigger "  $_.Name
                  $trig = Get-AzDataFactoryV2Trigger -name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName
                  if ($trig.RuntimeState -eq "Started") {
                      if ($_.TriggerType -eq "BlobEventsTrigger") {
                          Write-Host "Unsubscribing trigger" $_.Name "from events"
                          $status = Remove-AzDataFactoryV2TriggerSubscription -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                          while ($status.Status -ne "Disabled"){
                              Start-Sleep -s 15
                              $status = Get-AzDataFactoryV2TriggerSubscriptionStatus -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                          }
                      }
                      Stop-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name -Force 
                  }
                  Remove-AzDataFactoryV2Trigger -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }
              Write-Host "Deleting pipelines"
              $deletedpipelines | ForEach-Object { 
                  Write-Host "Deleting pipeline " $_.Name
                  Remove-AzDataFactoryV2Pipeline -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }
              Write-Host "Deleting dataflows"
              $deleteddataflow | ForEach-Object { 
                  Write-Host "Deleting dataflow " $_.Name
                  Remove-AzDataFactoryV2DataFlow -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }
              Write-Host "Deleting datasets"
              $deleteddataset | ForEach-Object { 
                  Write-Host "Deleting dataset " $_.Name
                  Remove-AzDataFactoryV2Dataset -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }
              Write-Host "Deleting linked services"
              $deletedlinkedservices | ForEach-Object { 
                  Write-Host "Deleting Linked Service " $_.Name
                  Remove-AzDataFactoryV2LinkedService -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }
              Write-Host "Deleting integration runtimes"
              $deletedintegrationruntimes | ForEach-Object { 
                  Write-Host "Deleting integration runtime " $_.Name
                  Remove-AzDataFactoryV2IntegrationRuntime -Name $_.Name -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Force 
              }

              if ($deleteDeployment -eq $true) {
                  Write-Host "Deleting ARM deployment ... under resource group: " $ResourceGroupName
                  $deployments = Get-AzResourceGroupDeployment -ResourceGroupName $ResourceGroupName
                  $deploymentsToConsider = $deployments | Where { $_.DeploymentName -like "ArmTemplate_master*" -or $_.DeploymentName -like "ArmTemplateForFactory*" } | Sort-Object -Property Timestamp -Descending
                  $deploymentName = $deploymentsToConsider[0].DeploymentName

                Write-Host "Deployment to be deleted: " $deploymentName
                  $deploymentOperations = Get-AzResourceGroupDeploymentOperation -DeploymentName $deploymentName -ResourceGroupName $ResourceGroupName
                  $deploymentsToDelete = $deploymentOperations | Where { $_.properties.targetResource.id -like "*Microsoft.Resources/deployments*" }

                  $deploymentsToDelete | ForEach-Object { 
                      Write-host "Deleting inner deployment: " $_.properties.targetResource.id
                      Remove-AzResourceGroupDeployment -Id $_.properties.targetResource.id
                  }
                  Write-Host "Deleting deployment: " $deploymentName
                  Remove-AzResourceGroupDeployment -ResourceGroupName $ResourceGroupName -Name $deploymentName
              }

              #Start active triggers - after cleanup efforts
              Write-Host "Starting active triggers"
              $triggersToStart | ForEach-Object { 
                  if ($_.TriggerType -eq "BlobEventsTrigger") {
                      Write-Host "Subscribing" $_.Name "to events"
                      $status = Add-AzDataFactoryV2TriggerSubscription -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                      while ($status.Status -ne "Enabled"){
                          Start-Sleep -s 15
                          $status = Get-AzDataFactoryV2TriggerSubscriptionStatus -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name
                      }
                  }
                  Write-Host "Starting trigger" $_.Name
                  Start-AzDataFactoryV2Trigger -ResourceGroupName $ResourceGroupName -DataFactoryName $DataFactoryName -Name $_.Name -Force
              }
          }            

        azPSVersion: '3.1.0'              

    # Deploy ADF items
    - name: Deploy ADF Artifacts (Pipelines)
      uses: azure/CLI@v1
      # if: ${{ github.event.inputs.MODE == 'SKIP FOR TESTING' }}
      with:
        inlineScript: |
          az deployment group create --resource-group ${{ github.event.inputs.RESOURCE_GROUP }} --template-file $GITHUB_WORKSPACE/Publish-Files/ARMTemplateForFactory.json --parameters @$GITHUB_WORKSPACE/Publish-Files/ARMTemplateParametersForFactory.json --parameters factoryName="${{ github.event.inputs.ADF_NAME }}"